import calendar as cal
import random
import pytz

from datetime import datetime, time
from dateutil import rrule
from dateutil.relativedelta import relativedelta
from babel.dates import format_datetime, format_time
from werkzeug.urls import url_encode

from odoo import api, fields, models, _
from odoo.exceptions import ValidationError
from odoo.tools.misc import babel_locale_parse, get_lang


class AppointmentType(models.Model):
    _inherit = "appointment.type"

    resource_manage_capacity = None
    capacity_type = fields.Selection(
        [
            ("one_booking", "One booking per slot"),
            ("multiple_bookings", "Multiple bookings per slot"),
            ("multiple_seats", "Multiple seats per slot"),
        ],
        string="Capacity",
        default="one_booking",
        required=True,
    )
    user_capacity = fields.Integer(
        help="Maximum number of appointments a user can handle concurrently.",
        default=1,
        required=True,
    )

    @api.constrains("capacity_type", "schedule_based_on", "user_capacity")
    def _check_user_capacity(self):
        """User capacity must be at least 1"""
        for rec in self:
            if rec.schedule_based_on == "users":
                if rec.capacity_type == "one_booking" and rec.user_capacity != 1:
                    raise ValidationError(
                        "In 'One Booking' mode, user capacity must be exactly 1."
                    )
                if rec.user_capacity < 1:
                    raise ValidationError("User capacity must be at least 1.")

    @api.depends("capacity_type")
    def _compute_resource_manage_capacity(self):
        for appointment in self:
            appointment.capacity_type == "one_booking"

    # -------------- RESOURCES ----------------

    def _slot_availability_is_resource_available(
        self, slot, resource, availability_values
    ):
        """This method verifies if the resource is available on the given slot.
        It checks whether the resource has bookings clashing and if it
        is included in slot's restricted resources.

        Can be overridden to add custom checks.

        :param dict slot: a slot as generated by ``_slots_generate``;
        :param <appointment.resource> resource: resource to check against slot boundaries.
          At this point timezone should be correctly set in context;
        :param dict availability_values: dict of data used for availability check.
          See ``_slot_availability_prepare_resources_values()`` for more details;

        :return: boolean: is resource available for an appointment for given slot
        """
        if (
            slot["slot"].restrict_to_resource_ids
            and resource not in slot["slot"].restrict_to_resource_ids
        ):
            return False

        slot_start_dt_utc, slot_end_dt_utc = slot["UTC"][0], slot["UTC"][1]
        resource_to_bookings = availability_values.get("resource_to_bookings")
        # Check if there is already a booking line for the time slot and make it available
        # only if the resource is shareable and the resource_manage_capacity is enable.
        # This avoid to mark the resource as "available" and compute unnecessary remaining capacity computation
        # because of potential linked resources.
        if resource_to_bookings.get(resource):
            if resource_to_bookings[resource].filtered(
                lambda bl: bl.event_start < slot_end_dt_utc
                and bl.event_stop > slot_start_dt_utc
            ):
                # return resource.shareable if self.resource_manage_capacity else False
                if self.capacity_type == "multiple_bookings":
                    return True
                elif self.capacity_type == "multiple_seats":
                    return resource.shareable

        # checks if the resource is unavailable for other reasons (eg.maintenance)
        slot_start_dt_utc_l, slot_end_dt_utc_l = (
            pytz.utc.localize(slot_start_dt_utc),
            pytz.utc.localize(slot_end_dt_utc),
        )
        for i_start, i_stop in availability_values.get(
            "resource_unavailabilities", {}
        ).get(resource, []):
            if (
                i_start != i_stop
                and i_start < slot_end_dt_utc_l
                and i_stop > slot_start_dt_utc_l
            ):
                return False

        return True

    def _slot_availability_select_best_resources(self, capacity_info, asked_capacity):
        """Check and select the best resources for the capacity needed
        :params main_resources_remaining_capacity <dict>: dict containing remaining capacities of resources available
        :params linked_resources_remaining_capacity <dict>: dict containing remaining capacities of linked resources
        :params asked_capacity <integer>: asked capacity for the appointment
        :returns: we return recordset of best resources selected
        """
        self.ensure_one()
        available_resources = (
            self.env["appointment.resource"]
            .concat(*capacity_info.keys())
            .sorted("sequence")
        )
        if not available_resources:
            return self.env["appointment.resource"]

        # if not self.resource_manage_capacity:
        #     return available_resources[0] if self.assign_method != 'time_resource' else available_resources
        if self.capacity_type == "one_booking":
            return (
                available_resources[0]
                if self.assign_method != "time_resource"
                else available_resources
            )

        perfect_matches = available_resources.filtered(
            lambda resource: resource.capacity == asked_capacity
            and capacity_info[resource]["remaining_capacity"] == asked_capacity
        )
        if perfect_matches:
            return (
                available_resources
                if self.assign_method == "time_resource"
                else perfect_matches[0]
            )

        first_resource_selected = available_resources[0]
        first_resource_selected_capacity_info = capacity_info.get(
            first_resource_selected
        )
        first_resource_selected_capacity = first_resource_selected_capacity_info[
            "remaining_capacity"
        ]
        capacity_needed = asked_capacity - first_resource_selected_capacity
        if capacity_needed > 0:
            # Get the best resources combination based on the capacity we need and the resources available.
            resource_possible_combinations = (
                available_resources._get_filtered_possible_capacity_combinations(
                    asked_capacity,
                    capacity_info,
                )
            )
            if not resource_possible_combinations:
                return self.env["appointment.resource"]
            if (
                asked_capacity
                <= first_resource_selected_capacity_info["total_remaining_capacity"]
                - first_resource_selected_capacity
            ):
                r_ids = (
                    first_resource_selected.ids
                    + first_resource_selected.linked_resource_ids.ids
                )
                resource_possible_combinations = list(
                    filter(
                        lambda cap: any(r_id in r_ids for r_id in cap[0]),
                        resource_possible_combinations,
                    )
                )
            resources_combinations_exact_capacity = list(
                filter(
                    lambda cap: cap[1] == asked_capacity, resource_possible_combinations
                )
            )
            resources_combination_selected = (
                resources_combinations_exact_capacity[0]
                if resources_combinations_exact_capacity
                else resource_possible_combinations[0]
            )
            return available_resources.filtered(
                lambda resource: resource.id in resources_combination_selected[0]
            )

        if self.assign_method == "time_resource":
            return available_resources

        return first_resource_selected

    # -------------- USERS ----------------

    # change - given ask_capacity parameter when user type
    def _get_appointment_slots(
        self,
        timezone,
        filter_users=None,
        filter_resources=None,
        asked_capacity=1,
        reference_date=None,
    ):
        """Fetch available slots to book an appointment.

        :param str timezone: timezone string e.g.: 'Europe/Brussels' or 'Etc/GMT+1'
        :param <res.users> filter_users: filter available slots for those users (can be a singleton
          for fixed appointment types or can contain several users, e.g. with random assignment and
          filters) If not set, use all users assigned to this appointment type.
        :param <appointment.resource> filter_resources: filter available slots for those resources
          (can be a singleton for fixed appointment types or can contain several resources,
          e.g. with random assignment and filters) If not set, use all resources assigned to this
          appointment type.
        :param int asked_capacity: the capacity the user want to book.
        :param datetime reference_date: starting datetime to fetch slots. If not
          given now (in UTC) is used instead. Note that minimum schedule hours
          defined on appointment type is added to the beginning of slots;

        :returns: list of dicts (1 per month) containing available slots per week
          and per day for each week (see ``_slots_generate()``), like
          [
            {'id': 0,
             'month': 'February 2022' (formatted month name),
             'weeks': [
                [{'day': '']
                [{...}],
             ],
            },
            {'id': 1,
             'month': 'March 2022' (formatted month name),
             'weeks': [ (...) ],
            },
            {...}
          ]
        """
        self.ensure_one()

        if not self.active:
            return []
        now = datetime.utcnow()
        if not reference_date:
            reference_date = now

        try:
            requested_tz = pytz.timezone(timezone)
        except pytz.UnknownTimeZoneError:
            requested_tz = self.appointment_tz

        appointment_duration_days = self.max_schedule_days
        unique_slots = self.slot_ids.filtered(lambda slot: slot.slot_type == "unique")

        if self.category == "custom" and unique_slots:
            # Custom appointment type, the first day should depend on the first slot datetime
            start_first_slot = unique_slots[0].start_datetime
            first_day_utc = (
                start_first_slot
                if reference_date > start_first_slot
                else reference_date
            )
            first_day = requested_tz.fromutc(
                first_day_utc + relativedelta(hours=self.min_schedule_hours)
            )
            appointment_duration_days = (
                unique_slots[-1].end_datetime.date() - reference_date.date()
            ).days
            last_day = requested_tz.fromutc(
                reference_date + relativedelta(days=appointment_duration_days)
            )
        elif self.category == "punctual":
            # Punctual appointment type, the first day is the start_datetime if it is in the future, else the first day is now
            first_day = requested_tz.fromutc(
                self.start_datetime if self.start_datetime > now else now
            )
            last_day = requested_tz.fromutc(self.end_datetime)
        else:
            # Recurring appointment type
            first_day = requested_tz.fromutc(
                reference_date + relativedelta(hours=self.min_schedule_hours)
            )
            last_day = requested_tz.fromutc(
                reference_date + relativedelta(days=appointment_duration_days)
            )

        # Compute available slots (ordered)
        slots = self._slots_generate(
            first_day.astimezone(pytz.utc),
            last_day.astimezone(pytz.utc),
            timezone,
            reference_date=reference_date,
        )

        # No slots -> skip useless computation
        if not slots:
            return slots
        valid_users = (
            filter_users.filtered(lambda user: user in self.staff_user_ids)
            if filter_users
            else None
        )
        valid_resources = (
            filter_resources.filtered(lambda resource: resource in self.resource_ids)
            if filter_resources
            else None
        )
        # Not found staff user : incorrect configuration -> skip useless computation
        if filter_users and not valid_users:
            return []
        if filter_resources and not valid_resources:
            return []
        # Used to check availabilities for the whole last day as _slot_generate will return all slots on that date.
        last_day_end_of_day = datetime.combine(
            last_day.astimezone(pytz.timezone(self.appointment_tz)), time.max
        )
        if self.schedule_based_on == "users":
            self._slots_fill_users_availability(
                slots,
                first_day.astimezone(pytz.UTC),
                last_day_end_of_day.astimezone(pytz.UTC),
                valid_users,
                asked_capacity,
            )
            slot_field_label = (
                "available_staff_users"
                if self.assign_method == "time_resource"
                else "staff_user_id"
            )
        else:
            self._slots_fill_resources_availability(
                slots,
                first_day.astimezone(pytz.UTC),
                last_day_end_of_day.astimezone(pytz.UTC),
                valid_resources,
                asked_capacity,
            )
            slot_field_label = "available_resource_ids"

        total_nb_slots = sum(slot_field_label in slot for slot in slots)
        # If there is no slot for the minimum capacity then we return an empty list.
        # This will lead to a screen informing the customer that there is no availability.
        # We don't want to return an empty list if the capacity as been tempered by the customer
        # as he should still be able to interact with the screen and select another capacity.
        if not total_nb_slots and asked_capacity == 1:
            return []
        nb_slots_previous_months = 0

        # Compute calendar rendering and inject available slots
        today = requested_tz.fromutc(reference_date)
        start = slots[0][timezone][0] if slots else today
        locale = babel_locale_parse(get_lang(self.env).code)
        month_dates_calendar = cal.Calendar(locale.first_week_day).monthdatescalendar
        months = []
        while (start.year, start.month) <= (last_day.year, last_day.month):
            nb_slots_next_months = sum(slot_field_label in slot for slot in slots)
            has_availabilities = False
            dates = month_dates_calendar(start.year, start.month)
            for week_index, week in enumerate(dates):
                for day_index, day in enumerate(week):
                    mute_cls = weekend_cls = today_cls = None
                    today_slots = []
                    if day.weekday() in (locale.weekend_start, locale.weekend_end):
                        weekend_cls = "o_weekend bg-light"
                    if day == today.date() and day.month == today.month:
                        today_cls = "o_today"
                    if day.month != start.month:
                        mute_cls = "text-muted o_mute_day"
                    else:
                        # slots are ordered, so check all unprocessed slots from until > day
                        while slots and (slots[0][timezone][0].date() <= day):
                            if (slots[0][timezone][0].date() == day) and (
                                slot_field_label in slots[0]
                            ):
                                slot_start_dt_tz = slots[0][timezone][0].strftime(
                                    "%Y-%m-%d %H:%M:%S"
                                )
                                slot = {
                                    "datetime": slot_start_dt_tz,
                                    "available_resources": [
                                        {
                                            "id": resource.id,
                                            "name": resource.name,
                                            "capacity": resource.capacity,
                                        }
                                        for resource in slots[0][
                                            "available_resource_ids"
                                        ]
                                    ]
                                    if self.schedule_based_on == "resources"
                                    else False,
                                }
                                if (
                                    self.schedule_based_on == "users"
                                    and self.assign_method == "time_resource"
                                ):
                                    slot.update(
                                        {
                                            "available_staff_users": [
                                                {
                                                    "id": staff.id,
                                                    "name": staff.name,
                                                }
                                                for staff in slots[0][
                                                    "available_staff_users"
                                                ]
                                            ]
                                        }
                                    )
                                elif self.schedule_based_on == "users":
                                    slot.update(
                                        {"staff_user_id": slots[0]["staff_user_id"].id}
                                    )
                                if slots[0]["slot"].allday:
                                    slot_duration = 24
                                    slot.update(
                                        {
                                            "hours": _("All day"),
                                            "slot_duration": slot_duration,
                                        }
                                    )
                                else:
                                    start_hour = format_time(
                                        slots[0][timezone][0].time(),
                                        format="short",
                                        locale=locale,
                                    )
                                    end_hour = (
                                        format_time(
                                            slots[0][timezone][1].time(),
                                            format="short",
                                            locale=locale,
                                        )
                                        if self.category == "custom"
                                        else False
                                    )
                                    slot_duration = str(
                                        (
                                            slots[0][timezone][1]
                                            - slots[0][timezone][0]
                                        ).total_seconds()
                                        / 3600
                                    )
                                    slot.update(
                                        {
                                            "start_hour": start_hour,
                                            "end_hour": end_hour,
                                            "slot_duration": slot_duration,
                                        }
                                    )
                                url_parameters = {
                                    "date_time": slot_start_dt_tz,
                                    "duration": slot_duration,
                                }
                                if (
                                    self.schedule_based_on == "users"
                                    and self.assign_method != "time_resource"
                                ):
                                    url_parameters.update(
                                        staff_user_id=str(slots[0]["staff_user_id"].id)
                                    )
                                elif self.schedule_based_on == "resources":
                                    url_parameters.update(
                                        available_resource_ids=str(
                                            slots[0]["available_resource_ids"].ids
                                        )
                                    )
                                slot["url_parameters"] = url_encode(url_parameters)
                                today_slots.append(slot)
                                nb_slots_next_months -= 1
                            slots.pop(0)
                    today_slots = sorted(today_slots, key=lambda d: d["datetime"])
                    dates[week_index][day_index] = {
                        "day": day,
                        "slots": today_slots,
                        "mute_cls": mute_cls,
                        "weekend_cls": weekend_cls,
                        "today_cls": today_cls,
                    }

                    has_availabilities = has_availabilities or bool(today_slots)

            months.append(
                {
                    "id": len(months),
                    "month": format_datetime(
                        start, "MMMM Y", locale=get_lang(self.env).code
                    ),
                    "weeks": dates,
                    "has_availabilities": has_availabilities,
                    "nb_slots_previous_months": nb_slots_previous_months,
                    "nb_slots_next_months": nb_slots_next_months,
                }
            )
            nb_slots_previous_months = total_nb_slots - nb_slots_next_months
            start = start + relativedelta(months=1)
        return months

    def _slots_fill_users_availability(
        self, slots, start_dt, end_dt, filter_users=None, asked_capacity=1
    ):
        """Fills the slot structure with an available user

        :param list slots: slots (list of slot dict), as generated by ``_slots_generate``;
        :param datetime start_dt: beginning of appointment check boundary. Timezoned to UTC;
        :param datetime end_dt: end of appointment check boundary. Timezoned to UTC;
        :param <res.users> filter_users: filter available slots for those users (can be a singleton
          for fixed appointment types or can contain several users e.g. with random assignment and
          filters) If not set, use all users assigned to this appointment type.

        :return: None but instead update ``slots`` adding ``staff_user_id`` or ``available_staff_users`` key
          containing available user(s);
        """
        # shuffle the available users into a random order to avoid having the same
        # one assigned every time, force timezone
        available_users = [
            user.with_context(tz=user.tz)
            for user in (filter_users or self.staff_user_ids)
        ]
        random.shuffle(available_users)
        available_users_tz = self.env["res.users"].concat(*available_users)

        # fetch value used for availability in batch
        availability_values = self._slot_availability_prepare_users_values(
            available_users_tz, start_dt, end_dt
        )

        for slot in slots:
            if self.assign_method == "time_resource":
                available_staff_users = available_users_tz.filtered(
                    lambda staff_user: self._slot_availability_is_user_available(
                        slot, staff_user, availability_values, asked_capacity
                    )
                )
            else:
                available_staff_users = next(
                    (
                        staff_user
                        for staff_user in available_users_tz
                        if self._slot_availability_is_user_available(
                            slot, staff_user, availability_values, asked_capacity
                        )
                    ),
                    False,
                )
            if available_staff_users:
                if self.assign_method == "time_resource":
                    slot["available_staff_users"] = available_staff_users
                else:
                    slot["staff_user_id"] = available_staff_users

    def _slot_availability_is_user_available(
        self, slot, staff_user, availability_values, asked_capacity=1
    ):
        """This method verifies if the user is available on the given slot.
        It checks whether the user has calendar events clashing and if he
        is included in slot's restricted users.

        Can be overridden to add custom checks.

        :param dict slot: a slot as generated by ``_slots_generate``;
        :param <res.users> staff_user: user to check against slot boundaries.
          At this point timezone should be correctly set in context;
        :param dict availability_values: dict of data used for availability check.
          See ``_slot_availability_prepare_users_values()`` for more details;
        :return: boolean: is user available for an appointment for given slot
        """
        slot_start_dt_utc, slot_end_dt_utc = slot["UTC"][0], slot["UTC"][1]
        staff_user_tz = pytz.timezone(staff_user.tz) if staff_user.tz else pytz.utc
        slot_start_dt_user_timezone = slot_start_dt_utc.astimezone(staff_user_tz)
        slot_end_dt_user_timezone = slot_end_dt_utc.astimezone(staff_user_tz)

        if (
            slot["slot"].restrict_to_user_ids
            and staff_user not in slot["slot"].restrict_to_user_ids
        ):
            return False

        partner_to_events = availability_values.get("partner_to_events") or {}

        # check existing bookings - in case of conflicting bookings
        # Rules for "multiple bookings"
        existing_bookings = self.env["appointment.booking.line"].search(
            [
                ("appointment_user_id", "=", staff_user.id),
                ("event_start", "<", slot_end_dt_utc),
                ("event_stop", ">", slot_start_dt_utc),
            ]
        )

        for booking in existing_bookings:
            if booking.appointment_type_id != self:
                return False

        if partner_to_events.get(staff_user.partner_id):
            for day_dt in rrule.rrule(
                freq=rrule.DAILY,
                dtstart=slot_start_dt_utc,
                until=slot_end_dt_utc,
                interval=1,
            ):
                day_events = (
                    partner_to_events[staff_user.partner_id].get(day_dt.date()) or []
                )
                # if any(not event.allday and (event.start < slot_end_dt_utc and event.stop > slot_start_dt_utc) for event in day_events):
                #     return False
                if self.capacity_type == "one_booking":
                    if any(
                        not event.allday
                        and (
                            event.start < slot_end_dt_utc
                            and event.stop > slot_start_dt_utc
                        )
                        for event in day_events
                    ):
                        return False
                elif self.capacity_type == "multiple_bookings":
                    user_remaining_capacity = self._get_user_remaining_capacity(
                        staff_user, slot_start_dt_utc, slot_end_dt_utc
                    )
                    if user_remaining_capacity <= 0:
                        return False
                elif self.capacity_type == "multiple_seats":
                    user_remaining_capacity = self._get_user_remaining_capacity(
                        staff_user, slot_start_dt_utc, slot_end_dt_utc
                    )
                    if user_remaining_capacity < asked_capacity:
                        return False
            for day_dt in rrule.rrule(
                freq=rrule.DAILY,
                dtstart=slot_start_dt_user_timezone,
                until=slot_end_dt_user_timezone,
                interval=1,
            ):
                day_events = (
                    partner_to_events[staff_user.partner_id].get(day_dt.date()) or []
                )
                if any(event.allday for event in day_events):
                    return False
        return True

    def _get_user_remaining_capacity(self, staff_user, slot_start, slot_end):
        """
        Calculate the remaining capacity of the user for a given slot based on capacity type.

        :param <res.users> staff_user: The user whose capacity is being checked.
        :param datetime slot_start_dt_utc: The start time of the slot in UTC.
        :param datetime slot_end_dt_utc: The end time of the slot in UTC.
        :return: The number of remaining available slots or seats for the user.
        """
        # get all booking lines for this user within the given time range
        booking_lines = self.env["appointment.booking.line"].search(
            [
                ("appointment_user_id", "=", staff_user.id),
                ("event_start", "<", slot_end),
                ("event_stop", ">", slot_start),
            ]
        )

        if self.capacity_type == "one_booking":
            # If any booking exists in this slot, return 0 (fully booked)
            return 0 if booking_lines else 1

        elif self.capacity_type == "multiple_bookings":
            # Count the number of bookings and reduce from user capacity
            return max(0, self.user_capacity - len(booking_lines))

        elif self.capacity_type == "multiple_seats":
            # Sum up the number of seats already booked from booking lines
            booked_seats = sum(booking.capacity_used for booking in booking_lines)
            return max(0, self.user_capacity - booked_seats)

        return 0
