import pytz
import re
import random
from dateutil import rrule

from odoo import models, fields, api
from odoo.exceptions import ValidationError
from odoo.http import request, route
from odoo.tools import float_compare


class AppointmentType(models.Model):
    _inherit = "appointment.type"

    capacity_type = fields.Selection(
        [
            ("single_booking", "Single Booking"),
            ("multiple_bookings", "Multiple Bookings"),
            ("multiple_seats", "Multiple Seats"),
        ],
        string="Capacity Type",
        required=True,
        default="single_booking",
    )

    user_capacity_count = fields.Integer(
        "User cpacity count",
        default=2,
        help="Maximum number of users bookings per slot (for multiple bookings or multiple seats).",
    )


    @api.constrains("user_capacity_count")
    def _check_user_capacity_count(self):
        for record in self:
            if (
                record.capacity_type in ["multiple_bookings", "multiple_seats"]
                and record.user_capacity_count <= 0
            ):
                raise ValidationError(
                    "Max Count must be greater than zero for multiple bookings or multiple seats."
                )
    @api.depends("capacity_type", "user_capacity_count")
    def _compute_available_capacity(self):
        for record in self:
            if not self.capacity_type != 'single_booking' and self.schedule_based_on == 'resources':
                self.resource_manage_capacity = True
                print(self.resource_manage_capacity)

            # max_capacity = record.user_capacity_count
            # total_reserved = self.env["appointment.booking.line"].search_count([
            #     ("appointment_type_id", "=", record.id),
            # ])
            # print(total_reserved)
            # record.available_capacity = max(0, max_capacity - total_reserved)
            # print("re",record.available_capacity)

    def _get_default_appointment_status(self, start_dt, stop_dt, capacity_reserved):
        """ Get the status of the appointment based on users/resources and the manual confirmation option.
        :param datetime start_dt: start datetime of appointment (in naive UTC)
        :param datetime stop_dt: stop datetime of appointment (in naive UTC)
        :param int capacity_reserved: capacity reserved by the customer for the appointment
        """
        self.ensure_one()
        default_state = 'booked'
        if self.appointment_manual_confirmation:
            bookings_data = self.env['appointment.booking.line'].sudo()._read_group([
                ('appointment_type_id', '=', self.id),
                ('event_start', '<', stop_dt),
                ('event_stop', '>', start_dt)
            ], [], ['capacity_used:sum'])
            capacity_already_used = bookings_data[0][0]
            total_capacity_used = capacity_already_used + (1 if self.capacity_type == 'multiple_bookings' else capacity_reserved)   #here make changes 
            total_capacity = self.resource_total_capacity if self.schedule_based_on == 'resources' else self.user_capacity_count

            if float_compare(total_capacity_used / total_capacity, self.resource_manual_confirmation_percentage, 2) > 0:
                default_state = 'request'
        elif self.appointment_manual_confirmation:
            default_state = 'request'
        return default_state

    def _slot_availability_is_resource_available(self, slot, resource, availability_values):
        """ This method verifies if the resource is available on the given slot.
        It checks whether the resource has bookings clashing and if it
        is included in slot's restricted resources.

        Can be overridden to add custom checks.

        :param dict slot: a slot as generated by ``_slots_generate``;
        :param <appointment.resource> resource: resource to check against slot boundaries.
          At this point timezone should be correctly set in context;
        :param dict availability_values: dict of data used for availability check.
          See ``_slot_availability_prepare_resources_values()`` for more details;

        :return: boolean: is resource available for an appointment for given slot
        """
        if slot['slot'].restrict_to_resource_ids and resource not in slot['slot'].restrict_to_resource_ids:
            return False

        slot_start_dt_utc, slot_end_dt_utc = slot['UTC'][0], slot['UTC'][1]
        resource_to_bookings = availability_values.get('resource_to_bookings')
        # Check if there is already a booking line for the time slot and make it available
        # only if the resource is shareable and the capacity_type is not single_booking.
        # This avoid to mark the resource as "available" and compute unnecessary remaining capacity computation
        # because of potential linked resources.
        if resource_to_bookings.get(resource):
            if resource_to_bookings[resource].filtered(lambda bl: bl.event_start < slot_end_dt_utc and bl.event_stop > slot_start_dt_utc):
                if self.capacity_type != "single_booking":
                    return True

        slot_start_dt_utc_l, slot_end_dt_utc_l = pytz.utc.localize(slot_start_dt_utc), pytz.utc.localize(slot_end_dt_utc)
        for i_start, i_stop in availability_values.get('resource_unavailabilities', {}).get(resource, []):
            if i_start != i_stop and i_start < slot_end_dt_utc_l and i_stop > slot_start_dt_utc_l:
                return False

        return True


    def _slot_availability_select_best_resources(self, capacity_info, asked_capacity):
        """ Check and select the best resources for the capacity needed
            :params main_resources_remaining_capacity <dict>: dict containing remaining capacities of resources available
            :params linked_resources_remaining_capacity <dict>: dict containing remaining capacities of linked resources
            :params asked_capacity <integer>: asked capacity for the appointment
            :returns: we return recordset of best resources selected
        """
        self.ensure_one()
        available_resources = self.env['appointment.resource'].concat(*capacity_info.keys()).sorted('sequence')
        if not available_resources:
            return self.env['appointment.resource']
        if self.capacity_type == 'single_booking':
            return available_resources[0] if self.assign_method != 'time_resource' else available_resources

        perfect_matches = available_resources.filtered(
            lambda resource: resource.capacity == asked_capacity and capacity_info[resource]['remaining_capacity'] == asked_capacity)
        if perfect_matches:
            return available_resources if self.assign_method == 'time_resource' else perfect_matches[0]

        first_resource_selected = available_resources[0]
        first_resource_selected_capacity_info = capacity_info.get(first_resource_selected)
        first_resource_selected_capacity = first_resource_selected_capacity_info['remaining_capacity']
        capacity_needed = asked_capacity - first_resource_selected_capacity
        if capacity_needed > 0:
            # Get the best resources combination based on the capacity we need and the resources available.
            resource_possible_combinations = available_resources._get_filtered_possible_capacity_combinations(
                asked_capacity,
                capacity_info,
            )
            if not resource_possible_combinations:
                return self.env['appointment.resource']
            if asked_capacity <= first_resource_selected_capacity_info['total_remaining_capacity'] - first_resource_selected_capacity:
                r_ids = first_resource_selected.ids + first_resource_selected.linked_resource_ids.ids
                resource_possible_combinations = list(filter(lambda cap: any(r_id in r_ids for r_id in cap[0]), resource_possible_combinations))
            resources_combinations_exact_capacity = list(filter(lambda cap: cap[1] == asked_capacity, resource_possible_combinations))
            resources_combination_selected = resources_combinations_exact_capacity[0] if resources_combinations_exact_capacity else resource_possible_combinations[0]
            return available_resources.filtered(lambda resource: resource.id in resources_combination_selected[0])

        if self.assign_method == 'time_resource':
            return available_resources

        return first_resource_selected

    # --------------------------------------
    # Staff Users - Slots Availability
    # --------------------------------------

    def _slots_fill_users_availability(self, slots, start_dt, end_dt, filter_users=None, asked_capacity=1):
        """ Fills the slot structure with an available user

        :param list slots: slots (list of slot dict), as generated by ``_slots_generate``;
        :param datetime start_dt: beginning of appointment check boundary. Timezoned to UTC;
        :param datetime end_dt: end of appointment check boundary. Timezoned to UTC;
        :param <res.users> filter_users: filter available slots for those users (can be a singleton
          for fixed appointment types or can contain several users e.g. with random assignment and
          filters) If not set, use all users assigned to this appointment type.

        :return: None but instead update ``slots`` adding ``staff_user_id`` or ``available_staff_users`` key
          containing available user(s);
        """
        # shuffle the available users into a random order to avoid having the same
        # one assigned every time, force timezone
        available_users = [
            user.with_context(tz=user.tz)
            for user in (filter_users or self.staff_user_ids)
        ]
        random.shuffle(available_users)
        available_users_tz = self.env['res.users'].concat(*available_users)

        # fetch value used for availability in batch
        availability_values = self._slot_availability_prepare_users_values(
            available_users_tz, start_dt, end_dt
        )

        for slot in slots:
            if self.assign_method == 'time_resource':
                available_staff_users = available_users_tz.filtered(
                    lambda staff_user: self._slot_availability_is_user_available(
                        slot,
                        staff_user,
                        availability_values,
                        asked_capacity
                    )
                )
            else:
                available_staff_users = next(
                    (staff_user for staff_user in available_users_tz if self._slot_availability_is_user_available(
                        slot,
                        staff_user,
                        availability_values,
                        asked_capacity
                    )),
                    False)
            if available_staff_users:
                if self.assign_method == 'time_resource':
                    slot['available_staff_users'] = available_staff_users
                else:
                    slot['staff_user_id'] = available_staff_users



    def _slot_availability_is_user_available(self, slot, staff_user, availability_values, asked_capacity=1):
        """ This method verifies if the user is available on the given slot.
        It checks whether the user has calendar events clashing and if he
        is included in slot's restricted users.

        Can be overridden to add custom checks.

        :param dict slot: a slot as generated by ``_slots_generate``;
        :param <res.users> staff_user: user to check against slot boundaries.
          At this point timezone should be correctly set in context;
        :param dict availability_values: dict of data used for availability check.
          See ``_slot_availability_prepare_users_values()`` for more details;
        :return: boolean: is user available for an appointment for given slot
        """
        slot_start_dt_utc, slot_end_dt_utc = slot['UTC'][0], slot['UTC'][1]
        staff_user_tz = pytz.timezone(staff_user.tz) if staff_user.tz else pytz.utc
        slot_start_dt_user_timezone = slot_start_dt_utc.astimezone(staff_user_tz)
        slot_end_dt_user_timezone = slot_end_dt_utc.astimezone(staff_user_tz)

        if slot['slot'].restrict_to_user_ids and staff_user not in slot['slot'].restrict_to_user_ids:
            return False

        partner_to_events = availability_values.get('partner_to_events') or {}
        users_remaining_capacity = self._get_users_remaining_capacity(staff_user, slot['UTC'][0], slot['UTC'][1],
            availability_values=availability_values)
        if partner_to_events.get(staff_user.partner_id):
            for day_dt in rrule.rrule(freq=rrule.DAILY,
                                      dtstart=slot_start_dt_utc,
                                      until=slot_end_dt_utc,
                                      interval=1):
                day_events = partner_to_events[staff_user.partner_id].get(day_dt.date()) or []
                # if any(not event.allday and (event.start < slot_end_dt_utc and event.stop > slot_start_dt_utc) for event in day_events):
                #     return False
                for event in day_events:
                    if not event.allday and (event.start < slot_end_dt_utc and event.stop > slot_start_dt_utc):
                        if self.capacity_type != "single_booking" and self == event.appointment_type_id:
                            if users_remaining_capacity['total_remaining_capacity'] >= asked_capacity:
                                continue
                        return False
            for day_dt in rrule.rrule(freq=rrule.DAILY,
                                      dtstart=slot_start_dt_user_timezone,
                                      until=slot_end_dt_user_timezone,
                                      interval=1):
                day_events = partner_to_events[staff_user.partner_id].get(day_dt.date()) or []
                if any(event.allday for event in day_events):
                    return False
        return True

    def _get_users_remaining_capacity(self, users, slot_start_utc, slot_stop_utc, availability_values=None):
        """ Compute the remaining capacities for users in a particular time slot.
            :param <res.users> users : record containing one or a multiple of users
            :param datetime slot_start_utc: start of slot (in naive UTC)
            :param datetime slot_stop_utc: end of slot (in naive UTC)
            :param list users_to_bookings: list of users linked to their booking lines from the prepared value.
                If no value is passed, then we search manually the booking lines (used for the appointment validation step)
            :param <res.users> filter_users: filter the users impacted with this value
            :return remaining_capacity:
        """
        self.ensure_one()

        all_users = users & self.staff_user_ids
        # if filter_users:
        #     all_users &= filter_users
        if not users:
            return {'total_remaining_capacity': 0}

        booking_lines = self.env['appointment.booking.line'].sudo()
        if availability_values is None:
            availability_values = self._slot_availability_prepare_users_values(all_users, slot_start_utc, slot_stop_utc)
        users_to_bookings = availability_values.get('users_to_bookings', {})
        users_remaining_capacity = {}
        print(users_to_bookings)
        for user, booking_lines_ids in users_to_bookings.items():
            if user in all_users:
                booking_lines |= booking_lines_ids
            booking_lines = booking_lines.filtered(lambda bl: bl.event_start < slot_stop_utc and bl.event_stop > slot_start_utc)

        users_booking_lines = booking_lines.grouped('appointment_user_id')

        for user in all_users:
            users_remaining_capacity[user] = self.user_capacity_count - sum(booking_line.capacity_used for booking_line in users_booking_lines.get(user, []))

        users_remaining_capacity.update(total_remaining_capacity=sum(users_remaining_capacity.values()))
        return users_remaining_capacity

